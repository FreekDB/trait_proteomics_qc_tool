package nl.ctmm.trait.proteomics.qcviewer;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

import nl.ctmm.trait.proteomics.qcviewer.gui.ViewerFrame;
import nl.ctmm.trait.proteomics.qcviewer.input.DataEntryForm;
import nl.ctmm.trait.proteomics.qcviewer.input.MetricsParser;
import nl.ctmm.trait.proteomics.qcviewer.input.ProgressLogMonitor;
import nl.ctmm.trait.proteomics.qcviewer.input.ProgressLogReader;
import nl.ctmm.trait.proteomics.qcviewer.input.ReportReader;
import nl.ctmm.trait.proteomics.qcviewer.input.ReportUnit;
import nl.ctmm.trait.proteomics.qcviewer.utils.Constants;

import org.jfree.ui.RefineryUtilities;

/**
 * The class that starts the QC Report Viewer.
 *
 * @author <a href="mailto:pravin.pawar@nbic.nl">Pravin Pawar</a>
 * @author <a href="mailto:freek.de.bruijn@nbic.nl">Freek de Bruijn</a>
 */
public class Main {
	private Properties applicationProperties = null; 
	private MetricsParser mParser = null;
	private String pipelineStatus = "";
    private Date fromDate = null, tillDate = null;
    private ViewerFrame frame;
    private DataEntryForm deForm;
    private int reportNum = 0; 
    //reportUnitsTable holds all the current reports in memory - new reports are added as they are generated by the
    //pipeline
    private Map<String, ReportUnit> reportUnitsTable = new HashMap<>();
    //Reads the pipeline log file - qc_status.log from the preferredRootDirectory
    private ProgressLogReader progressLogReader;
    //The directory to which QC pipeline writes the QC reports
    private String preferredRootDirectory;
    private static Main instance = new Main();
	/**
     * The logger for this class.
     */
    private static final Logger logger = Logger.getLogger(Main.class.getName());

    /**
     * The starting point for the QC Report Viewer.
     *
     * @param arguments the command-line arguments, which are currently not used.
     */
    public static void main(final String[] arguments) {
    	Main instance = Main.getInstance();
    	instance.runReportViewer();
    }

    /**
     * Gets the Main instance.
     * 
     * @return Main instance
     */
    public static Main getInstance() {
    	if (instance == null) {
    		instance = new Main();
    	}
      return instance;
    }
    
    /**
     * Start the QC Report Viewer.
     */
    public void runReportViewer() {
        applicationProperties = loadProperties();
        mParser = new MetricsParser(applicationProperties);
       	preferredRootDirectory = applicationProperties.getProperty(Constants.PROPERTY_ROOT_FOLDER);
        System.out.println("in Main preferredRootDirectory = " + preferredRootDirectory);
       	String progressLogFilePath = preferredRootDirectory + "\\" + Constants.PROPERTY_PROGRESS_LOG;
        System.out.println("progressLogFilePath = " + progressLogFilePath);
        progressLogReader = new ProgressLogReader(progressLogFilePath);
        pipelineStatus = progressLogReader.getCurrentStatus();
        
        deForm = new DataEntryForm(this, applicationProperties);
        deForm.setRootDirectoryName(preferredRootDirectory);
        deForm.displayInitialDialog();

        //Determine date interval for which to display reports for
        SimpleDateFormat sdf = new SimpleDateFormat(Constants.SIMPLE_DATE_FORMAT_STRING);
		sdf.setLenient(false);
		String reportsFromDate = applicationProperties.getProperty(Constants.PROPERTY_SHOW_REPORTS_FROM_DATE);
        String reportsTillDate = applicationProperties.getProperty(Constants.PROPERTY_SHOW_REPORTS_TILL_DATE);
        if (!reportsFromDate.trim().equals("") && !reportsFromDate.trim().equals("")) { //Dates are specified
        	//Check date format validity
        	try {
    			//if not valid, it will throw ParseException
    			fromDate = sdf.parse(reportsFromDate);
    			tillDate = sdf.parse(reportsTillDate);
    			System.out.println("fromDate = " + fromDate.toString() + " tillDate = " + tillDate.toString());
    			System.out.println("fromDate = " + sdf.format(fromDate) + " tillDate = " + sdf.format(tillDate));
    		} catch (ParseException e) {
    			fromDate = null;
    			tillDate = null;
    			e.printStackTrace();
    		}
        }
        if (tillDate == null) { //The date interval is not specified. 
        	tillDate = new Date(); //Till Date is current date
        	Calendar now = Calendar.getInstance();
        	now.add(Calendar.DATE, -14); 
        	fromDate = now.getTime();
        	System.out.println("fromDate = " + fromDate.toString() + " tillDate = " + tillDate.toString());
        	System.out.println("fromDate = " + sdf.format(fromDate) + " tillDate = " + sdf.format(tillDate));
        }
        System.out.println("fromDate = " + sdf.format(fromDate) + " tillDate = " + sdf.format(tillDate));
        //Obtain initial set of reports according to date filter 
        processInitialReports();
        //Start the progress log monitor to monitor qc_status.log file
        // TODO: keep a reference to this progressLogMonitor (declare as a field)? [Freek]
        final ProgressLogMonitor progressLogMonitor = ProgressLogMonitor.getInstance();
        try {
			progressLogMonitor.addFileChangeListener(progressLogReader, progressLogFilePath, 5000);
		} catch (FileNotFoundException e1) {
			e1.printStackTrace();
			System.out.println("progress log file not found. Configured path: " + progressLogFilePath);
		} //Refresh period is 5 seconds 
    }
    
    /**
     * Read initial set of QC Reports from the preferredRootDirectory. The reports are filtered according to date
     * criteria.
     */
    public void processInitialReports() { 
    	System.out.println("Reading initial set of reports..");
        final String runningMsrunName = progressLogReader.getRunningMsrunName();
        final List<ReportUnit> reportUnits = getReportUnits(preferredRootDirectory, fromDate, tillDate);
        //Reinitialize reportUnitsTable
        reportUnitsTable = new HashMap<>();
        reportNum = 0; 
        final List<ReportUnit> displayableReportUnits = new ArrayList<>();
        //populate reportUnitsTable
        final int reportUnitsSize = reportUnits.size();
        System.out.println("All reportUnitsSize = " + reportUnitsSize + " runningMsrunName = " + runningMsrunName);
        for (final ReportUnit thisUnit : reportUnits) {
            final String thisMsrun = thisUnit.getMsrunName();
            if (!thisMsrun.equals(runningMsrunName)) { //Currently processing this msrun. Do not include in the report
                ++reportNum;
                thisUnit.setReportNum(reportNum);
                //for identifying duplicate reports
                if (reportUnitsTable.containsKey(thisMsrun)) {
                    System.out.println("Alert!! Already exists in ReportUnitsTable " + thisMsrun);
                }
                //Update reportUnit in reportUnitsTable
                reportUnitsTable.put(thisUnit.getMsrunName(), thisUnit);
                displayableReportUnits.add(thisUnit);
            } else {
                System.out.println("Skipped report unit " + thisMsrun +
                                   " Logfile says it is running " + runningMsrunName);
            }
        }
        deForm.disposeInitialDialog();
        System.out.println("ReportUnitsTable size is " + reportUnitsTable.size());
        if (reportUnits.size() == 0) { //There exist no reports in current root directory
        	//Get new location to read reports from
        	deForm.displayErrorMessage("No Reports found in " + preferredRootDirectory);
        	deForm.displayRootDirectoryChooser();
        } else {
        	//Always start with GUI version
        	reportUnits.removeAll(reportUnits); //clear reportUnits
        	//Start main user interface
        	startQCReportViewerGui(applicationProperties, displayableReportUnits, pipelineStatus);
        }
    }
    
	/**Progress log file has changed. 
	 * Refresh ReportViewer automatically on this notification
	 */
    public void notifyProgressLogFileChanged(final String newPipelineStatus) {
   	 /* The tillDate has to be updated as currentTime - since the pipeline status has changed.
   	 * FromDate could be specified by the user
   	 */
        final String runningMsrunName = progressLogReader.getRunningMsrunName();
        final Calendar now = Calendar.getInstance();
		tillDate = now.getTime();
        final String preferredRootDirectory = applicationProperties.getProperty(Constants.PROPERTY_ROOT_FOLDER);
        final List<ReportUnit> reportUnits = getReportUnits(preferredRootDirectory, fromDate, tillDate);
		if (reportUnits.size() == 0) { //There exist no reports in current root directory
	      	//Get new location to read reports from
	       	deForm.displayErrorMessage("No Reports found in " + preferredRootDirectory);
	       	deForm.displayRootDirectoryChooser();
	    } else { 
	    	//Compare newReportUnits with reportUnits
	    	final List<ReportUnit> newReportUnits = new ArrayList<>();
	    	int numUpdates = 0;
            for (final ReportUnit thisUnit : reportUnits) {
                //if not in reportUnits, then add to newReportUnits
                final String thisMsrun = thisUnit.getMsrunName();
                if (!thisMsrun.equals(runningMsrunName)) {
                    // TODO: can someone explain the comment below? [Freek]
                    //Currently processing this msrun. Do not include in the report
                    if (reportUnitsTable.containsKey(thisMsrun)) {
                        ReportUnit existingUnit = reportUnitsTable.get(thisMsrun);
                        int existingNum = existingUnit.getReportNum();
                        //Assign this number to thisUnit and update reportUnitsTable
                        thisUnit.setReportNum(existingNum);
                        reportUnitsTable.remove(thisMsrun);
                        reportUnitsTable.put(thisMsrun, thisUnit);
                        ++numUpdates;
                    } else {
                        ++reportNum;
                        System.out.println("Does not exist in reportUnitsTable. " + thisUnit.getMsrunName() +
                                           " Adding to new report units with reportNum " + reportNum);
                        thisUnit.setReportNum(reportNum);
                        newReportUnits.add(thisUnit);
                        //Add to hashTable
                        reportUnitsTable.put(thisUnit.getMsrunName(), thisUnit);
                    }
                } else {
                    System.out.println("Skipped report unit " + thisMsrun +
                                       " Logfile says it is running " + runningMsrunName);
                }
            }
	    	System.out.println("ReportUnitsTable size is " + reportUnitsTable.size() + " Updated " + numUpdates +
                               " entries. newReportUnits size is " + newReportUnits.size());
	    	reportUnits.clear();
	    	//Refresh ViewerFrame with new Report Units
	    	frame.updateReportUnits(newReportUnits, newPipelineStatus);
	    }
	}
    
    /**Received notification about change in pipeline status.
     * Push new pipeline status to the report viewer
     * @param newPipelineStatus Updated pipeline status as read from the qc_status.log file
     */
    public void notifyUpdatePipelineStatus(String newPipelineStatus) {
		/* Refresh ReportViewer automatically on this notification
		 */
		pipelineStatus = newPipelineStatus; 
	    //Refresh ViewerFrame pipelineStatus
		if (frame != null) {
			frame.updatePipelineStatus(pipelineStatus);
		}
	}

    /**
     * Load the application properties from the properties file.
     *
     * @return the application properties.
     */
    private Properties loadProperties() {
        final Properties appProperties = new Properties();
        // Set default properties.
        appProperties.setProperty(Constants.PROPERTY_ROOT_FOLDER, Constants.DEFAULT_ROOT_FOLDER);
        appProperties.setProperty(Constants.PROPERTY_TOP_COLUMN_NAMESV2, Constants.DEFAULT_TOP_COLUMN_NAMES);
        // Load actual properties from file.
        try {
            final FileInputStream fileInputStream = new FileInputStream(Constants.PROPERTIES_FILE_NAME);
            appProperties.load(fileInputStream);
            fileInputStream.close();
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Loading of application properties failed.", e);
        }
        return appProperties;
    }

    /**
     * Get the report units from the directory structure below the root directory.
     *
     * @param rootDirectoryName the root directory to search in.
     * @param fromDate the start of the date range to search.
     * @param tillDate the end of the date range to search.
     * @return the list with report units.
     */
    private List<ReportUnit> getReportUnits(final String rootDirectoryName, Date fromDate, Date tillDate) {
        return new ReportReader(mParser).retrieveReports(rootDirectoryName, fromDate, tillDate);
    }

    /**
     * Create and start the GUI - of QC Report Viewer.
     *
     * @param appProperties the application properties.
     * @param reportUnits   the report units to be displayed.
     */
    private void startQCReportViewerGui(final Properties appProperties, final List<ReportUnit> reportUnits,
                                        final String pipelineStatus) {
    	System.out.println("Main startQCReportViewerGui");
    	final List<String> qcParamNames = getColumnNames(appProperties, Constants.PROPERTY_TOP_COLUMN_NAMESV2);
    	//Create ViewerFrame and set it visible
        frame = new ViewerFrame(mParser, appProperties, Constants.APPLICATION_NAME + " " + 
        		Constants.APPLICATION_VERSION, reportUnits, qcParamNames, pipelineStatus);
        frame.pack();
        RefineryUtilities.centerFrameOnScreen(frame);
        frame.setVisible(true);
    }
    
    /**
     * Get a property with a comma-separated string with column names and convert it into a list of strings.
     *
     * @param applicationProperties the application properties.
     * @param propertyName          the name of the property that contains the comma-separated string with column names.
     * @return the column names in a list of strings.
     */
    private List<String> getColumnNames(final Properties applicationProperties, final String propertyName) {
        return Arrays.asList(applicationProperties.getProperty(propertyName).split(","));
    }
}
