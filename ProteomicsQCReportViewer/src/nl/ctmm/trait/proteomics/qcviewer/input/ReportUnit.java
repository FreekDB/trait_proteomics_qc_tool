package nl.ctmm.trait.proteomics.qcviewer.input;

import java.awt.image.BufferedImage;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import nl.ctmm.trait.proteomics.qcviewer.gui.ChartUnit;
import nl.ctmm.trait.proteomics.qcviewer.utils.Utilities;

import org.jfree.data.xy.XYSeries;

/**
 * The object of this class represents report of single msrun.
 * <p/>
 * The <code>ReportUnit</code> class contains information from an MS run generated by the QC tool that are displayed by
 * the QC report viewer.
 *
 * @author <a href="mailto:pravin.pawar@nbic.nl">Pravin Pawar</a>
 * @author <a href="mailto:freek.de.bruijn@nbic.nl">Freek de Bruijn</a>
 */
public class ReportUnit {
    private static final Logger logger = Logger.getLogger(ReportUnit.class.getName());

    private int reportNum = -1;
    private String fileSizeString = "N/A";
    private String msrunName = ""; 
    private Double fileSize = -1.0;
    private String ms1Spectra = "N/A";
    private String ms2Spectra = "N/A";
    private String measured = "N/A";
    private String runtime = "N/A";
    private URI detailsUri; 
    private boolean errorFlag = false; //to signify that one or more files belonging to this report are missing
    
    // todo: only public setters for heatmapName and ioncountName; handle images internally.
/*    private BufferedImage heatmap = Utilities.getNotAvailableImage();
    private BufferedImage scaledHeatmap;
    private BufferedImage ioncount = Utilities.getNotAvailableImage();
    private String heatmapName = Utilities.NOT_AVAILABLE_ICON_NAME;
    private String ioncountName = Utilities.NOT_AVAILABLE_ICON_NAME;*/
    public HashMap<?, ?> metricsValues = null;
    //ChartUnit to hold corresponding chart
    private ChartUnit ticChartUnit = null;

    /**
     * One row in the QC Report Viewer table corresponds to one QC ReportUnit.
     * Sets the number of this QC ReportUnit.
     *
     * @param msrunName the unique msrun name - also represents RAW file uniquely
     * @param reportNum the unique report number.
     */
    public ReportUnit(String msrunName, int reportNum) {
        this.msrunName = msrunName;
        this.reportNum = reportNum;
        //Create default chart unit to handle problems due to missing series data 
        ticChartUnit = new ChartUnit(msrunName, reportNum, null);
    }

    /**
     * Get value of metrics based on metrics key - e.g. dyn:ds-1a
     * @param key metrics key in String format
     */
    public String getMetricsValueFromKey(String key) {
        String value = "N/A";
        if (metricsValues == null) { //Corresponding metrics.json file not found for this report
            return value; 
        } else if (metricsValues.containsKey(key)) {
            value = (String) metricsValues.get(key);
        } 
        return value;
    }

    /**
     * Get the value of parameter reportNum
     *
     * @param reportNum Serial number of current ReportUnit
     */
    public void setReportNum(int reportNum) {
        this.reportNum = reportNum;
    }
    
    /**
     * Get the value of parameter reportNum
     *
     * @return Serial number of current ReportUnit
     */
    public int getReportNum() {
        return reportNum;
    }

    /**
     * Get the value of parameter msrunName as a string.
     *
     * @return the unique msrun name - also represents RAW file uniquely
     */
    public String getMsrunName() {
        return msrunName;
    }

    /**
     * Get the value of errorFlag
     * 
     * @return value of errorFlag 
     */
    
    public boolean getErrorFlag() {
        return errorFlag; 
    }
    
    /**
     * Set the value of errorFlag
     * 
     */
    
    public void setErrorFlag(boolean flag) {
        errorFlag = flag; 
    }
    
    /**
     * Get the value of parameter fileSize as a string.
     *
     * @return size of the RAW MS data file (in MB)
     */
    public String getFileSizeString() {
        return fileSizeString;
    }

    /**
     * Get the value of parameter fileSize
     *
     * @return size of the RAW MS data file (in MB)
     */
    public Double getFileSize() {
        return fileSize;
    }

    /**
     * Create ticChart and corresponding chart data for this report unit 
     * @param series
     */
    public void createChartUnit(final XYSeries series) {
        if (ticChartUnit != null) {
            ticChartUnit = null;
        }
        ticChartUnit = new ChartUnit(msrunName, reportNum, series);
    }
    
    /**
     * Get ticChart and corresponding chart data for this report unit 
     * @return ChartUnit corresponding to this reportUnit
     */
    public ChartUnit getChartUnit() {
        return ticChartUnit;
    }
    
    /**
     * Set the value of parameter fileSize
     *
     * @param fileSizeString size of the RAW MS data file (in MB)
     */
    public void setFileSizeString(final String fileSizeString) {
    	if (fileSizeString == null) {
    		this.fileSizeString = "N/A";
    		fileSize = null;
    	} else {
            fileSize = (!fileSizeString.equals("N/A") && fileSizeString != null && !fileSizeString.trim().isEmpty())
                    ? Double.parseDouble(fileSizeString)
                    : null;
    	}
    }

    /**
     * Get the value of parameter ms1Spectra
     *
     * @return number of ms1 spectra
     */
    public String getMs1Spectra() {
        return this.ms1Spectra;
    }

    /**
     * Set the value of parameter detailsUri that points to detailed report on the server
     *
     * @param detailsUri Complete link address to report on the server
     */
    public void setDetailsUri(String detailsUri) {
        detailsUri = detailsUri.replace(" ", "%20");
        try {
            this.detailsUri = new URI(detailsUri);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
    }
    
    /**
     * Get the value of parameter detailsUri that points to detailed report on the server
     *
     * @return detailsUri Complete link address to report on the server
     */
    public URI getDetailsUri() {
        return detailsUri;
    }
    
    /**
     * Set the value of parameter ms1Spectra
     *
     * @param ms1Spectra number of ms1spectra
     */
    public void setMs1Spectra(String ms1Spectra) {
        this.ms1Spectra = ms1Spectra;
    }

    /**
     * Get the value of parameter ms2Spectra
     *
     * @return number of ms2spectra
     */
    public String getMs2Spectra() {
        return this.ms2Spectra;
    }

    /**
     * Set the value of parameter ms2Spectra
     *
     * @param ms2Spectra number of ms2spectra
     */
    public void setMs2Spectra(String ms2Spectra) {
        this.ms2Spectra = ms2Spectra;
    }

    /**
     * Get the value of parameter measured
     *
     * @return day and time at which QC processing of the RAW MS data file begun
     */
    public String getMeasured() {
        return this.measured;
    }

    /**
     * Set the value of parameter measured
     *
     * @param measured day and time at which QC processing of the RAW MS data file begun
     */
    public void setMeasured(String measured) {
        this.measured = measured;
    }

    /**
     * Get the value of parameter runtime
     *
     * @return time (in hh:mm:ss) taken to complete the QC processing of RAW data file
     */
    public String getRuntime() {
        return this.runtime;
    }

    /**
     * Set the value of parameter runtime
     *
     * @param runtime time (in hh:mm:ss) taken to complete the QC processing of RAW data file
     */
    public void setRuntime(String runtime) {
        this.runtime = runtime;
    }


    public void printReportValues() {
        logger.log(Level.ALL, "Num : " + this.reportNum + " fileSize = " + this.fileSizeString + " ms1Spectra = " +
                              this.ms1Spectra + " ms2Spectra = " + this.ms2Spectra + " measured = " + measured + " runtime = " +
                              runtime);
    }

    /**
     * Compare this report unit with other report unit based on sorting criteria
     * @param otherUnit Other report unit to be compared
     * @param sortKey Sorting criteria
     * @return if this report unit has higher value return 1, equal value return 0, lower value return -1
     */
    public int compareTo(final ReportUnit otherUnit, final String sortKey) {
        String thisValue = this.getMetricsValueFromKey(sortKey);
        String otherValue = otherUnit.getMetricsValueFromKey(sortKey);
        try {
            if (thisValue.equals(otherValue)) {
                return 0; 
            } else if (otherValue.equals("N/A")) { //thisValue is valid and present
                return 1;
            } else if (thisValue.equals("N/A")) { //otherValue is valid and present
                return -1;
            }else if (sortKey.equals("No.")) {
                if (this.reportNum > otherUnit.reportNum) {
                    return 1;
                } else if (this.reportNum < otherUnit.reportNum) {
                return -1;
                } else return 0; //equal reportNum
            } else if (sortKey.equals("generic:f_size")) {
                if (this.fileSize > otherUnit.fileSize) {
                    return 1;
                } else if (this.fileSize < otherUnit.fileSize) {
                    return -1;
                } else return 0;
            } else if (sortKey.equals("generic:ms1_spectra")) {
                int thisms1Spectra = Integer.parseInt(thisValue);
                int otherms1Spectra = Integer.parseInt(otherValue);
                if (thisms1Spectra > otherms1Spectra) {
                    return 1;
                } else if (thisms1Spectra < otherms1Spectra) {
                    return -1;
                } else return 0;
            } else if (sortKey.equals("generic:ms2_spectra")) {
                int thisms2Spectra = Integer.parseInt(thisValue);
                int otherms2Spectra = Integer.parseInt(otherValue);
                if (thisms2Spectra > otherms2Spectra) {
                    return 1;
                } else if (thisms2Spectra < otherms2Spectra) {
                    return -1;
                } else return 0;
            } else if (sortKey.equals("generic:date")) {
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MMM/dd - HH:mm");
                Date thisDate = sdf.parse(this.measured);
                Date otherDate = sdf.parse(otherUnit.measured);
                if (thisDate.compareTo(otherDate) > 0) {
                    return 1; 
                } else if (thisDate.compareTo(otherDate) < 0) {
                    return -1; 
                } else return 0;
            } else if (sortKey.equals("generic:runtime")) {
                if (this.runtime.compareToIgnoreCase(otherUnit.runtime) > 0) {
                    return 1;
                } else if (this.runtime.compareToIgnoreCase(otherUnit.runtime) < 0) {
                    return -1;
                } else return 0; 
            } else if (sortKey.equals("maxIntensity")) {
                if (this.getChartUnit().getMaxTicIntensity() > otherUnit.getChartUnit().getMaxTicIntensity()) { 
                    return 1;
                } else if (this.getChartUnit().getMaxTicIntensity() < otherUnit.getChartUnit().getMaxTicIntensity()) { 
                    return -1;
                } else return 0; 
            } else {
                double thisDouble = Double.parseDouble(thisValue);
                double otherDouble = Double.parseDouble(otherValue);
                if (thisDouble > otherDouble) { 
                    return 1;
                } else if (thisDouble < otherDouble) { 
                    return -1;
                } else return 0; 
            }
        } catch (Exception e) {
            System.out.println("Exception type " + e.getClass().toString() + " thisValue = " + thisValue + " otherValue = " + otherValue);
            e.printStackTrace();
        }
        return 0; 
    }
    
    /**
     * Set values of QC metrics in this report 
     * @param metricsValues Hashmap containing QC metrics keys and corresponding values 
     */
    public void setMetricsValues(HashMap<String, String> metricsValues) {
        if (metricsValues != null) {
            this.metricsValues = (HashMap<?, ?>) metricsValues.clone();
            //Set values of certain parameters to aid in the comparison
            this.fileSizeString = this.getMetricsValueFromKey("generic:f_size");
            setFileSizeString(fileSizeString);
            this.ms1Spectra = this.getMetricsValueFromKey("generic:ms1_spectra");
            this.ms2Spectra = this.getMetricsValueFromKey("generic:ms2_spectra");
            this.measured = this.getMetricsValueFromKey("generic:date");
            this.runtime = this.getMetricsValueFromKey("generic:runtime");
        }
    }
    
    /**
     * Set values of QC metrics in this report 
     * @return metricsValues Hashmap containing QC metrics keys and corresponding values 
     */
    public HashMap<?, ?> getMetricsValues() {
        if (metricsValues != null) {
            return metricsValues;
        } else return null;
    }
}
